데이터 삭제 (remove)
----------------------------------------------------------------------------------------------------------------------------------
db.book.remove()
// 전체를 삭제

db.book.remove({"name":"def"})
// 해당 Document 리스트를 모두 삭제

예)
> db.book.find()
{ "_id" : ObjectId("5b7cc764a45a717920ccdd832e"), "name" : "def"}
{ "_id" : ObjectId("5b7cc764a45a717920ccdd832f"), "name" : "def"}
{ "_id" : ObjectId("5b7cc764a45a717920ccdd8330"), "name" : "ghi"}
{ "_id" : ObjectId("5b7cc764a45a717920ccdd8331"), "name" : "def"}
> db.book.remove({"name":"def"})
WriteResult({"nRemoved" : 3})
> db.book.find()
{ "_id" : ObjectId("5b7cc764a45a717920ccdd8330"), "name" : "ghi"}
----------------------------------------------------------------------------------------------------------------------------------
 

DeleteOne, DeleteMany
-deleteOne은 매칭되는 첫 번째 다큐먼트만 지움
-deleteMany는 매칭되는 모든 다큐먼트를 지움
-remove 메소드를 세분화한 것이다.
----------------------------------------------------------------------------------------------------------------------------------
db.monsters.deleteOne({ name: 'Zerp' });
----------------------------------------------------------------------------------------------------------------------------------


Tip
remove를 deleteOne, deleteMany로 나눈 이유?

예를들어, 댓글 테이블에 삭제 버튼을 누르면 remove 된다고 하면
remove는 기본적으로 다중 삭제 처리라서, 나는 해당 댓글 하나만 삭제하려고 하나의 버튼을 눌렀는데 여러개가 지워질수있다는 위험성을 안고 있다.

물론 Object.id 를 통해 다른 다큐먼트와 관계를 맺어서 지우는거니, 
당연히 중복(다중 처리)이 발생할리는 없겠지만, 
만일 유니크하지않은 다른 필드로 검색했을때 다중으로 지워질수 있는 실수를 미연에 방지하고, 
보다 개발자로 하여금 직관적으로 메서드를 행함을(하나만 처리해라, 여러개 처리해라) 표현하기 위해 api를 추가로 만들었다라고 이해하면 된다.
