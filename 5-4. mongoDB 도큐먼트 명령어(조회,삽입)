다큐먼트 명령어
 

데이터 삽입 (insert)
insert- 단일 또는 다수의 Document를 입력할 때 사용. 만일 컬렉션이 존재하지않는다면 자동으로 생성재주고 insert해준다.
insertOne - 단일 Document를 입력할 때 사용
insertMany - 다수의 Document를 입력할 때 사용
------------------------------------------------------------------------------------------------------------------------------------------------
db.book.insert({"name":"abc"})

// 여러개를 넣을때는 배열로 묶는다.
db.book.insert([ 
    {"name":"abc"}, 
    {"name":"def"} 
])
Copy
JAVASCRIPT
db.book.insert({
    "name":"A", 
    "hits":100, 
    "auther":[
        {"name":"park"},
        {"name":"lee"}
    ]
});

db.book.insert({
    "name":"B", 
    "hits":50, 
    "auther":[
        {"name":"kim"}
    ]
});

db.book.insert({
    "name":"C", 
    "hits":30, 
    "auther":[
        {"name":"kim"},
        {"name":"choi"}
    ]
});
------------------------------------------------------------------------------------------------------------------------------------------------

데이터 조회 (find)
------------------------------------------------------------------------------------------------------------------------------------------------
// Document 리스트를 확인
db.books.find() 

// 다큐먼트를 좀더 깔끔하게 보여준다.
db.book.find().pretty() 

// name이 A인 document을 조회한다.
db.book.find({"name":"A"}).pretty()

예)
>ad.book.find().pretty()
{
      "_id" : ObbjectId("618e31a4146987b7eccef3"),
      "name" : "A",
      "hits" : 10000,
      "auther" : [
              {
                  "name" : "park"
              },
              {
                  "name" : "lee"
              }
      ]
}
{
      "_id" : ObbjectId("618e31a4146987b7eccef4"),
      "name" : "B",
      "hits" : 50,
      "auther" : [
              {
                  "name" : "kim"
              }
      ]
}
{
      "_id" : ObbjectId("618e31a4146987b7eccef5"),
      "name" : "C",
      "hits" : 30,
      "auther" : [
              {
                  "name" : "kim"
              },
              {
                  "name" : "choi"
              }
      ]
}

TIP
id 필드의 ObjectId("618ejhsdke8121kf")는 몽고DB에서 자동으로 넣어주는 고유값.
------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------------------------------
db.monsters.findOne({ name: 'Slime' });
// 단 하나만 찾고 싶을 때 사용. find(...)[0]과도 같다. 
// find 메소드로 찾은 것 중에 첫 번째 것을 선택
------------------------------------------------------------------------------------------------------------------------------------------------

논리 연산자
------------------------------------------------------------------------------------------------------------------------------------------------
{ 필드: { $gt: 값 } } // 필드 > 값
{ 필드: { $lt: 값 } } // 필드 < 값
{ 필드: { $gte: 값 } } // 필드 >= 값
{ 필드: { $lte: 값 } } // 필드 <= 값

{ 필드: { $eq: 값 } } // 필드 == 값
{ 필드: { $ne: 값 } } // 필드 != 값

{ 필드: { $in: [ 값1, 값2, 값3, ... ] } // 필드 == (값1 or 값2 or 값3)
{ 필드: { $nin: [ 값1, 값2, 값3, ... ] } // 필드 != (값1 and 값2 and 값3)
------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------
// 조건1 or 조건2
{ $or: [ { 조건1 }, { 조건2 }, ... ] } 


// 조건이 간단하면 그냥 { 필드: 값, 필드: 값 } 이렇게 $and가 없어도 되지만, 여러 논리연산자를 겹쳐 쓸 경우 $and가 필요합니다.
// (조건1 or 조건2) and (조건3 or 조건4)
{ $and: [
  { $or: [{ 조건1 }, { 조건2 }] },
  { $or: [{ 조건3 }, { 조건4 }] }
] }


// 조건1, 조건2 ... 모두 만족하지 않는 다큐먼트
{ $nor: [{ 조건1 }, { 조건2 }, ...] } 

// 조건이 아닌값.  $nor의 단일 버전
{ $not: { 조건 } }
------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------
// name이 Slime 그리고 hp가 25인 다큐먼트. 둘다 일치
db.monsters.find({ 
    name: 'Slime',
    hp: 25 
}); // 하나의 객체에 두개의 키

// name이 Slime 또는 hp가 50. 
db.monsters.find({ 
    $or: [ 
        { name: 'Slime' }, 
        { hp: 50 } 
    ] 
}); // 배열에 두개의 객체
------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------
db.book.find({
    "hits": {$gte:50}
})
// hits >= 50인 document를 조회한다.

db.book.find({
    "hits": {$gt:40, $lt:70}
})
// hits가 40 초과 70 미만. 40 < hits < 70
------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------
db.book.find({
    "name":{
        $in:["A","B"]
    }
}) // name이 A or B인 Document

db.book.find({
    $or:[
        {"name":"A"},
        {"hits":50}
    ]
}) // name이 A 혹은 hits가 50인 Document

db.book.find({
    $and:[
        {"hits":{$lte:50}}, 
        {"name":"B"}
    ] 
}) // (hits < 50) and (name == B)인 Document
------------------------------------------------------------------------------------------------------------------------------------------------
 

정규식 $regex
------------------------------------------------------------------------------------------------------------------------------------------------
db.book.find({"name": {$regex: /a|b/, $options:"i"}})
db.book.find({"name": /a|b/i}).pretty()
// a또는 b 를 정규식으로 검색 option: i는 대소문자 무시
------------------------------------------------------------------------------------------------------------------------------------------------
 

조건 $where
자바스크립트 문법을 사용해 검색할 수 있다
this를 반드시 써줘야 인식 된다.
------------------------------------------------------------------------------------------------------------------------------------------------
db.book.find({
    $where: "this.name == 'A'"
})
// $where을 이용하면 자바스크립트 표현식(expression)을 사용할 수 있다.


// 다음 쿼리를 $where로 간단하게 표현 가능하다.
db.book.find({ $or: [ {name: 'A'}, {hits: {$lte: 50}} ] })
// ==
db.book.find({ $where: "this.name == 'A' || this.hits <= 50" })

예)
>bd.book.find({$or:[{name: 'A'},{hits:{$lte: 50}}]})
{"_id" : ObjectId("618e31a414694987b7eccef3"), "name" : "A", "hits" : 500}
{"_id" : ObjectId("618e31a414694987b7eccef3"), "name" : "B", "hits" : 50}
{"_id" : ObjectId("618e31a414694987b7eccef3"), "name" : "C", "hits" : 30}
>bd.book.find({$where: "this.name == 'A' || this.hits <= 50"})
{"_id" : ObjectId("618e31a414694987b7eccef3"), "name" : "A", "hits" : 500}
{"_id" : ObjectId("618e31a414694987b7eccef3"), "name" : "B", "hits" : 50}
{"_id" : ObjectId("618e31a414694987b7eccef3"), "name" : "C", "hits" : 30}
------------------------------------------------------------------------------------------------------------------------------------------------
 
정렬 sort
------------------------------------------------------------------------------------------------------------------------------------------------
db.book.find()
	.sort({"hits":1})
    .pretty()
// hits를 오름차순으로 정렬해서 조회
// 1은 오름차순, -1은 내림차순

예)
>bd.book.find().sort({hits:1}).pretty();
{
      "_id" : ObbjectId("618e31a4146987b7eccef5"),
      "name" : "C",
      "hits" : 30,   <===이부분 (위의 hits가 1이니 오름차순)
      "auther" : [
              {
                  "name" : "kim"
              },
              {
                  "name" : "choi"
              }
      ]
}
{
      "_id" : ObbjectId("618e31a4146987b7eccef4"),
      "name" : "A",
      "hits" : 50,    <===이부분 (위의 hits가 1이니 오름차순)
      "auther" : [
              {
                  "name" : "kim"
              }
      ]
}
{
      "_id" : ObbjectId("618e31a4146987b7eccef3"),
      "name" : "A",
      "hits" : 10000,    <===이부분 (위의 hits가 1이니 오름차순)
      "auther" : [
              {
                  "name" : "park"
              },
              {
                  "name" : "lee"
              }
      ]
}
------------------------------------------------------------------------------------------------------------------------------------------------
 

선택 필드 Projection
projection이란 find와 findOne 메소드의 두 번째 인자로 넣어주는 것을 말한다.
결과로 보여줄 것만 필터링하는 기능을 가진다.
projection이 유용한 경우는 민감한 데이터가 있을 경우다.
만약 댓글을 단 회원의 정보를 가져오고 싶은데 회원 정보를 통째로 가져오면 비밀번호나 개인 정보같은 게 모두 가져와지는데, 그럴 때 projection 객체를 사용해서 가져올 데이터만 걸러내는 것이다.
또한 한 가지 더 장점은 용량이 줄어드는 것이다.
게시글 리스트에서 게시글들을 모두 불러오면 용량이 어마어마하다.
게시글 제목, 내용, 댓글까지 다 불러와지기 때문에, 이럴 때 제목만 불러오도록 하면 데이터를 아낄 수 있다.
------------------------------------------------------------------------------------------------------------------------------------------------
db.book.find({}, {"_id":false, "name":true, "hits":true});
// 2번째 인자값은 option으로 보여질 Field에 대한 결정을 함

db.book.find( {$and:[{"name":"A"}]}, {"auther":{$slice:1}} )
// $slice를 하면 해당 갯수만큼의 Document만큼만 갖고온다.
------------------------------------------------------------------------------------------------------------------------------------------------

이렇게 생각하면 간단하다.

기본적으로 몽고디비의 find( { 내용1 } ) 은 sql의 select * from 테이블 where 내용1 과 같다.
즉, find의 첫번째 객체인자는 where로 특정 다큐먼트를 골라 * 전체를 가져오는것이고

find( { 내용1 }, { 내용2 } ) 두번째 인자가 바로 select 내용2 from 테이블 where 내용1 과 같다고 보면 된다.
어떤걸 select해서 가져와서 민감한 데이터를 감출지 그 역할이다.

즉, 몽고디비는 SQL과는 달리 첫째 인자에 where이 오고 둘째 인자에 select 필드가 온다고 보면 된다.
